02-Traits


Definition : Traits are pretty much another word for status effects. They affect a Creature, and can be given by scripted events, spells, equipping an item,  at player character creation by the chosed class/race scripts (in Data folder), or at creature creation from a bestiary entry (check Realmz Remake\shared_assets\Bestiary\stuff_book.json).

Traits are also used for Guard, Parry and Prepare combat abilities.
Those are defined in the class.gd files for Player Characters.

You should be able to understand alot just by looking at the examples.


CTRL+F :
1-How they are added to Creatures
2-How to create a Trait script
3-How they work




1-How they are added to Creatures :



Traits are added  bu the function :
Creature.add_trait(traitscript, trait_array : Array)
where traitscript is a loaded GDScript and trait_array is an array of the arguments used to initialize the trait (power, duration, etc).

A text String can be converted to a GDScript this way , if text is proper GD code :
var newscript : GDScript = GDScript.new()
newscript.set_source_code(text)
var _err_newscript_reload = newscript.reload()

However, you may not always want to use one of the traits that has been loaded from  either the base game (because it's missing, likely) or from the Campaign folder (for example, for an item you want to be able to use in other campaigns).
For that, you can just enter the source code of the trait script as a string in the JSON file (bestiary/stuff_book.json or items/stuff_book) :

For the bestiary :
      "traits" : [  ["regeneration_over_time.gd", [-1,1]]  ] ,
Here, "regeneration_over_time.gd" is  the  "text" definition of the trait entry ["regeneration_over_time.gd", [1, -1]]  and [-1,1] is its parameters used for its initialization (here, power of 1 and infinite duration of -1).
If the text ends with  ".gd", the game understands it's the name of  a gdscript file and looks it up the base game and campaign folder's trait folders.
Else, the game understands it's plain source code and attempts to convert it to a GDScript object.

For the Items :
	"traits" : [["Blue Ox Regeneration", [-1,1] ]],
Again, if the text ends with .gd  the game will load a pre-existing trait script with this file name.
Else, like in this case, the game will look up the source in another dictionary entry with the same name followed by "_source" :

	"Blue Ox Regeneration_source" :
"
const name = 'Blue Ox Regeneration'
const menuname = 'Blue Ox Regeneration'
const stacks = false  #one instance per applied effect, removed instance chosen if equals_args
var power = 1
func _init(args : Array):
	power = args[0]
	return
func _on_time_pass(character, s : int) :
	print('shield blue oxen time pass script ! ')
	character.stats['curHP'] += s*power
	character.name = 'debug'
func equals_args(args : Array) ->bool :
	return  (power == args[0])
"




2-How to write a Trait script :



Script files are text files with a .gd extension. If you are not displaying file extensions, you should for MANY reasons.
Those are located in Realmz Remake\shared_assets\traits  and Realmz Remake Folder\Campaigns\CAMPAIGN\traits .
NOTE THAT TRAITS ARE NOT LOADED ALONG WITH THE REST OF THE SCENARIO DATA WHEN THE GAME STARTS.
IMPORTANT : For this reason, I had to find a quick way to determine where each trait file is located just by its name, and decided that the names of all trait files in the campaign's traits folder should start with the campaign's name
example :  City of Bywater customtrait.gd

all trait scripts should have the following variables and constants :

const name : String = 'filename.gd'
const menuname : String = 'The Name is is Displayed As While In-Game'
var power : int = 0 # only for display in the menu, still required. Usually changed on initialization
#the Creature it affects, important if the trait can remove itself due to duration
#or removing itself at the end of battle.
#This is now set automatically after the initialization, but some older scripts I wrote still pass it in the args.
var chara  

The following are optionnal but can be necessary for some kinds  of traits :


#The "family" of  the trait, used to check for example if it's a kind of Poison or a Parry stance  ("Prep.")  , atatcks of opportunity immunity ("AoO_imm")...
#Here, Family is Preparing stances, 
const trait_type : String = "Prep."		
#for Preparing traits, whether this one can be used every round to stack up bonuses. Disables the Prepare button in game (checks "prep_can_use_every_round" variable)
const prep_can_use_every_round  : bool = false

When a Trait is given to a Creature, it is initialized by :

func _init(args : Array):
	chara = args[0]
	power = args[1]

This should usually set the trait's var chara, if you want he spell to remove itself from the list of the character's active traits (usually traits with a set duration). Other variables like power, duration, etc should be set here.

If the character already had a trait with this name  (or when attempting to remove effects from a stacking trait like Poison), those functions are used instead :
func stack(args : Array) :
func unstack(args : Array) :
This can be useful when you don't want a trait to become unbalanced at high power, like Enchanted Blades or Regeneration.

Traits that remove themselves at the end of battle should have :

Traits that persist out of battle must implement this function :
func get_saved_variables() :
	return [chara.name,power, duration]


func get_saved_variables() :
	print("trait  'preparing.gd'  shouldnt be active out of combat, get_saved_variables should never happen")
	return [duration]




3-How they work :



Whenever something happens out of battle (time passes, character is affected by a spell..) or in battle (on evasion attempt, on accuracy check, on any creature moving, on being targeted by a melee attack or spell...), the game looks up every trait of the affected creatures and calls the appropriate function if the trait has one implemented :
CURRENTLY IMPLEMENTED CHECKS :
func _on_time_pass(character, seconds : int) :		#can happen both in and out of battle, actually.
func _on_new_round(character) :
func _on_battle_end(character) :
func _on_other_creature_walked(othercreabutton : CombatCreaButton) :	#used for Guarding
func _on_evasion_check(crea, evasion_stats_used : Array, attacker) :   #not called for spells with perfect accuracy
func _on_get_stat(statname : String, stat : int) :  #stat is the stat of the creature  before it gets modified (or not)

func _on_before_melee_attack(attacker : CombatCreaButton, damage_detail : Dictionary)>Array :
damage_detail  is a Dictionary as generated  by GameGlobal.calculate_melee_damage
the returned array are :
[do_melee_attack : bool, new_attacker: CombatCreaButton, new_defender : CombatCreaButton, new_attack_data : Dictionary]

func _on_crea_death(creature) ; #triggered after the creature dies. called by  creature.die()

I should probably  add those :
 _on_resurection,
_on_before_spell_hit_taken, _on_spell_hit_taken,
_on_before_spell_cast, _on_spell_cast_done,
 _on_melee_attack_done
